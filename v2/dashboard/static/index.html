<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options Breakout Tracker V2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .status-connected { background: #00ff88; }
        .status-disconnected { background: #ff4444; }
        .status-reconnecting { background: #ffaa00; animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .phase-badge {
            padding: 6px 16px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        .phase-waiting { background: #6c757d; }
        .phase-lookback { background: #0d6efd; }
        .phase-entry_signal { background: #ffc107; color: #000; }
        .phase-monitoring { background: #198754; }
        .phase-completed { background: #6f42c1; }

        .countdown {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00d4ff;
        }

        .symbols-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .symbol-card {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .symbol-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .symbol-name {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .target-badge {
            background: rgba(255,255,255,0.1);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.9rem;
        }

        .options-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .option-box {
            padding: 15px;
            border-radius: 12px;
            background: rgba(255,255,255,0.05);
        }

        .option-box.ce {
            border-left: 4px solid #00ff88;
        }

        .option-box.pe {
            border-left: 4px solid #ff6b6b;
        }

        .option-type {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 8px;
        }

        .option-strike {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .option-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 0.9rem;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
        }

        .detail-label {
            color: #888;
        }

        .detail-value {
            font-weight: 500;
        }

        .detail-value.profit { color: #00ff88; }
        .detail-value.loss { color: #ff6b6b; }
        .detail-value.sl-hit { color: #ff4444; font-weight: bold; }

        .positions-section {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
            margin-top: 20px;
        }

        .positions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .positions-header h2 {
            font-size: 1.2rem;
        }

        .total-pnl {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .positions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .position-card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
        }

        .position-card.sl-hit {
            border: 2px solid #ff4444;
            animation: flash 0.5s ease-in-out;
        }

        @keyframes flash {
            0%, 100% { background: rgba(255,68,68,0.1); }
            50% { background: rgba(255,68,68,0.3); }
        }

        .position-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .position-symbol {
            font-weight: bold;
        }

        .position-type {
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.8rem;
        }

        .position-type.ce { background: rgba(0,255,136,0.2); color: #00ff88; }
        .position-type.pe { background: rgba(255,107,107,0.2); color: #ff6b6b; }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }

        .footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.85rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .symbols-grid {
                grid-template-columns: 1fr;
            }
            .options-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Options Breakout Tracker V2</h1>
        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="connection-indicator"></div>
                <span id="connection-status">Connecting...</span>
            </div>
            <div class="status-item">
                <span class="phase-badge" id="phase-badge">WAITING</span>
            </div>
            <div class="status-item">
                <span>Entry Time:</span>
                <span class="countdown" id="countdown">--:--</span>
            </div>
            <div class="status-item">
                <span>Ticks:</span>
                <span id="tick-count">0</span>
            </div>
        </div>
    </div>

    <div class="symbols-grid" id="symbols-container">
        <div class="no-data">Waiting for data...</div>
    </div>

    <div class="positions-section" id="positions-section" style="display: none;">
        <div class="positions-header">
            <h2>Positions</h2>
            <div class="total-pnl" id="total-pnl">P&L: Rs.0.00</div>
        </div>
        <div class="positions-grid" id="positions-container"></div>
    </div>

    <div class="footer">
        <p>Options Breakout Tracker V2 | WebSocket Real-time Updates</p>
        <p id="last-update">Last update: --</p>
    </div>

    <script>
        // WebSocket connection
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        const reconnectInterval = 3000;

        function connect() {
            const wsUrl = `ws://${window.location.host}/ws`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                reconnectAttempts = 0;
                updateConnectionStatus('connected');
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                updateConnectionStatus('disconnected');
                attemptReconnect();
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus('error');
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    updateDashboard(data);
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            };
        }

        function attemptReconnect() {
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                updateConnectionStatus('reconnecting');
                setTimeout(connect, reconnectInterval);
            }
        }

        function updateConnectionStatus(status) {
            const indicator = document.getElementById('connection-indicator');
            const statusText = document.getElementById('connection-status');

            indicator.className = 'status-indicator';

            switch (status) {
                case 'connected':
                    indicator.classList.add('status-connected');
                    statusText.textContent = 'Connected';
                    break;
                case 'disconnected':
                    indicator.classList.add('status-disconnected');
                    statusText.textContent = 'Disconnected';
                    break;
                case 'reconnecting':
                    indicator.classList.add('status-reconnecting');
                    statusText.textContent = `Reconnecting (${reconnectAttempts}/${maxReconnectAttempts})...`;
                    break;
                case 'error':
                    indicator.classList.add('status-disconnected');
                    statusText.textContent = 'Error';
                    break;
            }
        }

        function updateDashboard(data) {
            // Update phase
            updatePhase(data.phase);

            // Update tick count
            document.getElementById('tick-count').textContent = data.tick_count || 0;

            // Update countdown
            updateCountdown(data.entry_time);

            // Update symbols
            updateSymbols(data.symbols || {});

            // Update positions
            updatePositions(data.positions || [], data.summary || {});

            // Update last update time
            document.getElementById('last-update').textContent =
                `Last update: ${new Date().toLocaleTimeString()}`;
        }

        function updatePhase(phase) {
            const badge = document.getElementById('phase-badge');
            badge.className = 'phase-badge';
            badge.classList.add(`phase-${phase}`);
            badge.textContent = phase ? phase.toUpperCase().replace('_', ' ') : 'WAITING';
        }

        function updateCountdown(entryTime) {
            if (!entryTime) return;

            const countdown = document.getElementById('countdown');
            const now = new Date();
            const [hours, minutes] = entryTime.split(':').map(Number);
            const target = new Date(now);
            target.setHours(hours, minutes, 0, 0);

            const diff = target - now;

            if (diff <= 0) {
                countdown.textContent = 'LIVE';
                countdown.style.color = '#00ff88';
            } else {
                const mins = Math.floor(diff / 60000);
                const secs = Math.floor((diff % 60000) / 1000);
                countdown.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                countdown.style.color = '#00d4ff';
            }
        }

        function updateSymbols(symbols) {
            const container = document.getElementById('symbols-container');

            if (Object.keys(symbols).length === 0) {
                container.innerHTML = '<div class="no-data">Waiting for data...</div>';
                return;
            }

            let html = '';

            for (const [name, data] of Object.entries(symbols)) {
                html += `
                    <div class="symbol-card">
                        <div class="symbol-header">
                            <span class="symbol-name">${name}</span>
                            <span class="target-badge">Target: Rs.${data.target_premium}</span>
                        </div>
                        <div class="options-container">
                            ${renderOptionBox('CE', data.selected_ce, data.ce_strikes, data.target_premium)}
                            ${renderOptionBox('PE', data.selected_pe, data.pe_strikes, data.target_premium)}
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function renderOptionBox(type, selected, strikes, target) {
            const typeClass = type.toLowerCase();
            const nearest = findNearestToTarget(strikes, target);

            if (selected) {
                const pnl = selected.unrealized_pnl || 0;
                const pnlClass = pnl >= 0 ? 'profit' : 'loss';
                const slClass = selected.is_sl_hit ? 'sl-hit' : '';

                return `
                    <div class="option-box ${typeClass}">
                        <div class="option-type">${type} (Position)</div>
                        <div class="option-strike">${selected.strike}</div>
                        <div class="option-details">
                            <div class="detail-row">
                                <span class="detail-label">Entry:</span>
                                <span class="detail-value">Rs.${selected.entry_price.toFixed(2)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">LTP:</span>
                                <span class="detail-value">Rs.${selected.current_ltp.toFixed(2)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">SL:</span>
                                <span class="detail-value ${slClass}">Rs.${selected.stop_loss.toFixed(2)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">P&L:</span>
                                <span class="detail-value ${pnlClass}">Rs.${pnl.toFixed(2)}</span>
                            </div>
                            ${selected.is_sl_hit ? '<div class="detail-row"><span class="detail-value sl-hit">STOP LOSS HIT!</span></div>' : ''}
                        </div>
                    </div>
                `;
            }

            if (nearest) {
                return `
                    <div class="option-box ${typeClass}">
                        <div class="option-type">${type} (Nearest to target)</div>
                        <div class="option-strike">${nearest.strike}</div>
                        <div class="option-details">
                            <div class="detail-row">
                                <span class="detail-label">Low:</span>
                                <span class="detail-value">Rs.${nearest.low ? nearest.low.toFixed(2) : '--'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">LTP:</span>
                                <span class="detail-value">Rs.${nearest.ltp ? nearest.ltp.toFixed(2) : '--'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Distance:</span>
                                <span class="detail-value">Rs.${nearest.distance_to_target ? nearest.distance_to_target.toFixed(2) : '--'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Ticks:</span>
                                <span class="detail-value">${nearest.tick_count || 0}</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="option-box ${typeClass}">
                    <div class="option-type">${type}</div>
                    <div class="no-data">No data yet</div>
                </div>
            `;
        }

        function findNearestToTarget(strikes, target) {
            if (!strikes || Object.keys(strikes).length === 0) return null;

            let nearest = null;
            let minDistance = Infinity;

            for (const data of Object.values(strikes)) {
                if (data.low && data.distance_to_target !== null) {
                    if (data.distance_to_target < minDistance) {
                        minDistance = data.distance_to_target;
                        nearest = data;
                    }
                }
            }

            return nearest;
        }

        function updatePositions(positions, summary) {
            const section = document.getElementById('positions-section');
            const container = document.getElementById('positions-container');
            const totalPnl = document.getElementById('total-pnl');

            if (positions.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';

            // Update total P&L
            const pnl = summary.total_unrealized_pnl || 0;
            const pnlClass = pnl >= 0 ? 'profit' : 'loss';
            totalPnl.innerHTML = `P&L: <span class="${pnlClass}">Rs.${pnl.toFixed(2)}</span>`;

            // Update positions
            let html = '';

            for (const pos of positions) {
                const typeClass = pos.option_type.toLowerCase();
                const pnlVal = pos.unrealized_pnl || 0;
                const pnlValClass = pnlVal >= 0 ? 'profit' : 'loss';
                const slHitClass = pos.is_sl_hit ? 'sl-hit' : '';

                html += `
                    <div class="position-card ${slHitClass}">
                        <div class="position-header">
                            <span class="position-symbol">${pos.symbol}</span>
                            <span class="position-type ${typeClass}">${pos.option_type} ${pos.strike}</span>
                        </div>
                        <div class="option-details">
                            <div class="detail-row">
                                <span class="detail-label">Entry:</span>
                                <span class="detail-value">Rs.${pos.entry_price.toFixed(2)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Current:</span>
                                <span class="detail-value">Rs.${pos.current_ltp.toFixed(2)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">P&L:</span>
                                <span class="detail-value ${pnlValClass}">Rs.${pnlVal.toFixed(2)} (${pos.unrealized_pnl_percent.toFixed(1)}%)</span>
                            </div>
                            ${pos.is_sl_hit ? '<div class="detail-row"><span class="detail-value sl-hit">SL HIT @ Rs.' + pos.sl_hit_price.toFixed(2) + '</span></div>' : ''}
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Initialize
        connect();

        // Update countdown every second
        setInterval(() => {
            const countdown = document.getElementById('countdown');
            const text = countdown.textContent;
            if (text && text !== 'LIVE' && text !== '--:--') {
                // Re-trigger countdown update
            }
        }, 1000);
    </script>
</body>
</html>
